# COMP212-2022-CA-Assignment1
Coordination and Leader Election Developing, Simulating and Evaluating Distributed Protocols in Java

This repository contains java files for the first assignment of COMP212 Distributed Systems 2021-2022.

The distributed algorithm LCR has been implemented for task 3.1, which is a ring structure asynchronous network. The network requires that all processors should eventually terminate and know the `leaderID`.

The distributed algorithm LCR has been implemented for task 3.2, which is a rings of rings structure network. The network also requires that all processors in tha main ring should eventually terminate and know the `leaderID`.

**The general flow of the program is described below**:
First, you need to enter the integer 1 or 2 to select the task of 3.1 or 3.2 in the simulation job, respectively.

**As for the implementation of 3.1**, the program requires you to first enter the total number of processors,  then the number of processors initially sleeping,  and finally the maximum possible sleep time for the sleeping processors. Note that this is the maximum possible sleep time. The sleep time of each asleep processor is randomly generated by the program in the interval [1, max-sleep-time]. and the sleep time randomly generated by the program may not reach the maximum value you inputted.

After the input is completed, the program will randomly generate a `uniqueID` that does not repeat for each processor in the range [1, 3n]. n is the number of processors. Including which nodes are initially in sleep state, and how long to sleep, is also randomly generated by the program.

After that, the program will build a ring network based on the generated processor information and simulate the LCR algorithm. Then, the program will output two sets of information at each time round.  The first set is the internal state of each processor after judging the information sent by the previous processor (that is, the `sendID` of each processor has been determined).  And the second set is the internal state of each processor after receiving the information from the previous processor (that is, the `receiveID` of each processor has been determined).

Finally, the program will output two lines of measurement results. The first line is the number of time rounds and the number of messages sent when the leader is just elected. And the second line is the number of time rounds that has passed and the number of messages sent when all processors have terminated. 

A note about the processor state, the processor has a total of 4 states:

1. **UNKNOWN**: Indicates that the processor is awake but does not know the leader's information

2. **KNOWN**: Indicates that the processor is awake and knows the leader's information but it is not the leader
3. **LEADER**: Indicates that the processor is the leader
4. **ASLEEP**: Indicates that this processor is asleep



**As for the implementation of 3.2**, the program requires you to first enter the total number of non-interface processors, that include the non-interface processors in the main ring and subring. Then you need to input the number of processor in the main ring, that include both interface processor and non-interface processor. At last, you need to input the number of interface processor. Please be noted that, when you enter the number of interface processor, the program will give you a hint about the valid interval of this number. Please enter an considerable integer according to that.

After all the required inputs are entered, the program will randomly generate subrings' position on the main ring, its size and all non-interface processors' ID.

The remaining output part is similar to part 3.1. Therefore, no more explanation at here.
